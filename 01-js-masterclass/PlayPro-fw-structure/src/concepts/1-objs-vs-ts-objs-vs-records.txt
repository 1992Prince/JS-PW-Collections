1. Object in JavaScript

In JavaScript, an object is just a collection of key‚Äìvalue pairs.

// JavaScript object
const user = {
  name: "Alice",
  age: 25,
};

// Accessing values
console.log(user.name);    // Alice
console.log(user["age"]);  // 25


    - Keys are usually strings (or symbols).

    - No type checking ‚Üí you can add/remove properties freely.

user.role = "Engineer"; // works, no complaints
delete user.age;        // works, no complaints






2. Object in TypeScript

TypeScript builds on JavaScript objects but adds types to describe the shape.

// TS object with a fixed shape
type User = {
  name: string;
  age: number;
};

const user: User = {
  name: "Alice",
  age: 25,
};

// Access
console.log(user.name); // Alice

üîí Now TypeScript enforces rules:

user.age = "25";  // ‚ùå Error (must be number)
user.role = "Dev"; // ‚ùå Error (role not in type)

üëâ This is a typed object ‚Äî you declare what keys and value types are allowed



üëâ -  in TS object, we define type like above u created User now can we create an object user of type User but 
       with only name and no age?

       In the example I wrote:

       type User = {
        name: string;
        age: number;
      };

      When you declare:

      const user: User = {
        name: "Alice"
      };

      üëâ This will give an error because age is required in the User type.

‚úÖ How to make age optional

        You can mark a property optional with ?:

        type User = {
            name: string;
            age?: number; // optional
          };
          
          const user1: User = { name: "Alice" };         // ‚úÖ valid
          const user2: User = { name: "Bob", age: 25 };  // ‚úÖ valid
          





3. Record in TypeScript

Record<K, T> is a utility type that creates an object type with:

    - Keys (K)

    - Values (T)

// Equivalent: { [key in K]: T }



‚úÖExample 1: Record with string keys

const userRoles: Record<string, string> = {
    alice: "Engineer",
    bob: "Designer",
  };
  
  console.log(userRoles["alice"]); // Engineer
  
  This is very similar to { [key: string]: string }.


‚úÖExample 2: Record with union of keys (stronger typing)

  Here‚Äôs the real power:

  type User = "alice" | "bob";

const userRoles: Record<User, string> = {
  alice: "Engineer",
  bob: "Designer",
  // charlie: "Manager", ‚ùå Error, not allowed
};

console.log(userRoles.alice); // Engineer

üëâ Unlike plain objects, Record can enforce exact keys (no extras, no missing ones).


4. Comparison
| Feature    | JavaScript Object            | TypeScript Object               | Record                                |                  |
| ---------- | ---------------------------- | ------------------------------- | ------------------------------------- | ---------------- |
| Typing     | None (dynamic)               | Can define explicit properties  | Utility type to generate object types |                  |
| Example    | `{ name: "Alice" }`          | `{ name: string; age: number }` | \`Record<'alice'                      | 'bob', string>\` |
| Key type   | String/Symbol (runtime only) | Defined in type                 | Union of keys (strict)                |                  |
| Value type | Anything                     | Defined per property            | Same type for all values              |                  |
| Safety     | ‚ùå none                       | ‚úÖ safer                         | ‚úÖ‚úÖ very strict when using union keys  |                  |


5. Rule of Thumb

    - JavaScript object ‚Üí flexible, but unsafe.

    - TypeScript object type ‚Üí best for fixed, known shapes.

    - Record ‚Üí best for ‚Äúdictionary-like‚Äù structures where keys are all the same type, 
    especially if you know the set of keys up front.

‚úÖ Example where Record is better:

type Language = "en" | "fr" | "es";

const greetings: Record<Language, string> = {
  en: "Hello",
  fr: "Bonjour",
  es: "Hola",
  // de: "Hallo" ‚ùå Not allowed, keeps type safe
};

With just an object, you‚Äôd risk typos or missing keys.