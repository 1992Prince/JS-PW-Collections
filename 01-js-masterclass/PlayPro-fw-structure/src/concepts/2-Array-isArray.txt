[IGNORE For NOW and CLEAN IT UP LATER]

ğŸ”¹ 1. Array.isArray()

Array.isArray(value) check karta hai ki jo value hai wo array hai ya nahi.
Agar array hai â†’ true return karega
Agar array nahi hai â†’ false return karega


JS/TS me arrays bhi technically "object" hote hain:

typeof [1, 2, 3] // "object"
typeof { a: 1 }  // "object"

so now in below fun

export function getJsonObject(key: string): Record<string, any> {

    const testData = loadTestData();

    if (!(key in testData)) {
        throw new Error(`Key "${key}" not found in test data`);
    }

    const value = testData[key];
    if (typeof value !== "object" || Array.isArray(value)) {
        throw new Error(`Key "${key}" does not contain a JSON object`);
    }

    return value;
}

agar tu sirf typeof value === "object" check karega, to array bhi pass ho jaayega.
Lekin tu chah raha hai sirf plain JSON object return karna, array nahi.
Isliye:

if (typeof value !== "object" || Array.isArray(value)) {
    throw new Error("not a JSON object");
 }
 

 Ye ensure karta hai:

    Agar value primitive (string, number, boolean) hai â†’ reject
    Agar value array hai â†’ reject
    Agar value null hai â†’ reject (kyunki typeof null === "object")
    Sirf plain object {} allow hoga âœ…


ğŸ”¹ Case 1: Primitive values (string, number, boolean)

typeof "rahul"    // "string"
typeof 123        // "number"
typeof true       // "boolean"

â¡ï¸ typeof value !== "object" â†’ âœ… true hoga â†’ error throw karega.
ğŸ‘‰ Matlab primitive reject ho jaayenge.


ğŸ”¹ Case 2: Array

typeof [1,2,3]    // "object"
Array.isArray([1,2,3]) // true

â¡ï¸ typeof value !== "object" â†’ false
â¡ï¸ Array.isArray(value) â†’ true
ğŸ‘‰ false || true = true â†’ error throw hoga.
âœ… Array reject ho jaayega.


ğŸ”¹ Case 3: null

typeof null   // "object" (JS ka historical bug)
Array.isArray(null) // false

â¡ï¸ typeof value !== "object" â†’ false
â¡ï¸ Array.isArray(null) â†’ false
ğŸ‘‰ false || false = false â†’ âŒ error nahi aayega â†’ null allow ho jaayega.

âš ï¸ Yaha dikkat hai: agar tu null ko bhi reject karna chahta hai (aur usually JSON object me null ko "object" 
nahi maana jata), to extra check chahiye:

if (typeof value !== "object" || value === null || Array.isArray(value)) {
    throw new Error(`Key "${key}" does not contain a JSON object`);
}


ğŸ”¹ Case 4: Plain object

typeof { username: "rahul" } // "object"
Array.isArray({}) // false
value !== null // true

â¡ï¸ Sab condition fail â†’ error nahi throw hoga.
âœ… Ye allow hoga.



    ğŸ”¹ 2. Why return type is Record<string, any>?

    TypeScript me plain JS object ko describe karne ka ek common tariqa hai Record:

    Record<string, any>

    Matlab:

    Keys â†’ string

    Values â†’ kuch bhi (any)

    Example:

    const obj: Record<string, any> = {
        username: "rahul",
        password: "pass123"
      };

      Is case me tu keh raha hai: "Mujhe ek aisa object chahiye jisme keys string hain aur values kuch bhi ho 
      sakti hain" â†’ jo ki sahi hai kyunki tera JSON dynamic hai.      


      ğŸ”¹ 3. Could we use plain object instead?

      Haan, theoretically tu likh sakta hai:

      export function getJsonObject(key: string): object { ... }

      Lekin dikkat ye hai:

object type TS me bahut restrictive hai â†’ tu usse property access directly nahi kar sakta.

Example:

const obj: object = { username: "rahul" };
console.log(obj.username); // âŒ Error: Property 'username' does not exist


ğŸ”¹ 4. Why Record<string, any> is better

Record<string, any> bole to TypeScript ko pata hai ki object ke andar string keys hain aur unki values accessible hain:

const obj: Record<string, any> = { username: "rahul" };
console.log(obj.username); // âœ… Allowed

Yahi reason hai ki aise functions ke liye Record<string, any> preferred hota hai instead of object.