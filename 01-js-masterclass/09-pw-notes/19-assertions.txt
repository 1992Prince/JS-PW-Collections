âœ… What are Negating Matchers?

A matcher is what you use in a test to check a condition. Normally, you expect something to be true.

But sometimes, you want to check that something is NOT true â€” thatâ€™s where .not comes in.

You simply insert .not before the matcher.

1. Basic Value Check

    expect(value).not.toEqual(0);

    means: â€œI expect value is anything except 0.â€

    If value was 0, the test would fail.

2. String/Text Check

    const sentence = "This is a clean text";
    expect(sentence).not.toContain("error");  // âœ… passes

3. Playwright / Locator Example

    const button = page.locator('button#submit');
    await expect(button).not.toBeDisabled();   // âœ… passes if button is enabled


ðŸ”¹ Why Useful?

- Ensures certain bad values/states do NOT appear.

- Negative testing â†’ making sure app doesnâ€™t do something wrong.

- Good for validations like:

    - User should not see an error.

    - Button should not be disabled.

    - List should not contain duplicates.





-----------------------------------------------------------------------


ðŸ”¹ What are Soft Assertions?

Normal (Hard) Assertion â†’ If an assertion fails, the test execution stops immediately.

Soft Assertion â†’ If an assertion fails, the test keeps running, but the failure is recorded. At the end, 
                 the test will still be marked as failed.

ðŸ‘‰ Useful when you want to check multiple conditions in one test without stopping at the first failure.


ðŸ”¹ Example 1: Hard vs Soft Assertion

Hard Assertion
----------------------

test('hard assertion stops execution', async ({ page }) => {
  await expect(page.locator('#status')).toHaveText('Success'); // âŒ fails, test stops here
  await expect(page.locator('#eta')).toHaveText('1 day');       // âŒ never runs
});

If #status is not "Success", the test exits immediately â†’ you donâ€™t know if #eta was wrong too.


Soft Assertion
--------------------

test('soft assertions continue execution', async ({ page }) => {
  await expect.soft(page.locator('#status')).toHaveText('Success'); // âŒ fails but continues
  await expect.soft(page.locator('#eta')).toHaveText('1 day');      // âœ…/âŒ runs regardless

  // Continue with more steps
  await page.getByRole('link', { name: 'next page' }).click();
  await expect.soft(page.getByRole('heading', { name: 'Make another order' })).toBeVisible();
});

ðŸ‘‰ Even if the first check fails, the test continues â€” but at the end, Playwright marks the test as failed.



ðŸ”¹ Example 2: Soft Assertions with Conditional Stop

Sometimes you want to run multiple checks, but stop if too many fail.


test('stop only if soft assertions failed', async ({ page }) => {
  await expect.soft(page.getByTestId('status')).toHaveText('Success');
  await expect.soft(page.getByTestId('eta')).toHaveText('1 day');

  // Check if any soft assertion failed before continuing
  expect(test.info().errors).toHaveLength(0);

  // This only runs if no errors so far
  await page.getByRole('link', { name: 'next page' }).click();
  await expect.soft(page.getByRole('heading', { name: 'Make another order' })).toBeVisible();
});


Here:

If either status or eta check fails â†’ test.info().errors contains errors, and the test stops early.

If both pass â†’ execution continues.


ðŸ”¹ Example 3: Real-World Case (Login Page)

test('login page validations with soft assertions', async ({ page }) => {
  await page.goto('/login');

  // Multiple field checks
  await expect.soft(page.locator('#username-label')).toHaveText('Username');
  await expect.soft(page.locator('#password-label')).toHaveText('Password');
  await expect.soft(page.locator('#submit-btn')).toBeEnabled();

  // Proceed with login anyway
  await page.fill('#username', 'testUser');
  await page.fill('#password', 'wrongPass');
  await page.click('#submit-btn');

  // Verify error message
  await expect.soft(page.locator('#error-msg')).toContainText('Invalid');
});


ðŸ‘‰ Even if the labels are wrong, the login flow is still tested.


ðŸ”‘ Key Takeaways

    - Use expect.soft(...) to not block test execution.

    - At the end, you can check test.info().errors to decide if the test should continue.

    - Works only in Playwright test runner (not in raw Jest/Mocha).

    - Best used when verifying UI elements, multiple fields, or page content at once.




ðŸ”¹ Do we need to explicitly fail the test at the end when using expect.soft()?

ðŸ‘‰ No, you donâ€™t need to.


Playwrightâ€™s test runner automatically collects all failed soft assertions and marks the test as failed in the 
report at the end of execution.

So this works fine without extra code:

test('soft assertions demo', async ({ page }) => {
  await expect.soft(page.locator('#status')).toHaveText('Success');
  await expect.soft(page.locator('#eta')).toHaveText('1 day');

  // Even if both fail, test continues.
  // âœ… At the end, Playwright marks the test as failed automatically.
});




--------------------------------------------------------


ðŸ”¹ What is a Custom Expect Message?

Normally, when an assertion fails, you only see the matcher and the actual/expected values in the test report.
But sometimes itâ€™s hard to immediately understand what business rule you were testing.

Thatâ€™s where a custom message helps.

You pass a string message as the second argument to expect(...).

ðŸ”¹ Example

await expect(page.getByText('Name'), 'should be logged in').toBeVisible();

Here:

    page.getByText('Name') â†’ Locator

    'should be logged in' â†’ Custom message



ðŸ”¹ Why is this Useful?

    - Better test reports â†’ Especially in CI/CD pipelines where you might see dozens of failures.

    - Debugging is easier â†’ Instead of guessing which element failed, you see a human-readable reason.

    - Readable by non-developers â†’ QA/business analysts can understand test reports better.