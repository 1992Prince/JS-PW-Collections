https://playwright.dev/docs/locators
https://docs.google.com/document/d/1fwdOZeaIQ8BKxZtLPxR-0OQnR2dpu9WfuDGNRM1G1Bw/edit?tab=t.0

ğŸ”µ Locators

ğŸ§  Introduction

Locators are the central piece of Playwright's auto-waiting and retry-ability. 
In a nutshell, locators represent a way to find element(s) on the page at any moment.


These are the recommended built-in locators.

- page.getByRole() to locate by explicit and implicit accessibility attributes.
- page.getByText() to locate by text content.
- page.getByLabel() to locate a form control by associated label's text.
- page.getByPlaceholder() to locate an input by placeholder.
- page.getByAltText() to locate an element, usually image, by its text alternative.
- page.getByTitle() to locate an element by its title attribute.
- page.getByTestId() to locate an element based on its data-testid attribute 
                     (other attributes can be configured).



ğŸ–¥ï¸ What is a Locator in Playwright?

  - In Playwright, a locator is an object that represents a way to find and interact with 
    one or more elements on a page.

  - Think of it as a "live pointer" to elements in the DOM â€” it doesnâ€™t fetch the element 
    immediately; instead, it knows how to find it when you need it.

  - Important: page.locator() does not actually go and find the element right away.
    It only finds the element when an action (like .click(), .fill(), .hover(), .textContent()) 
    is executed.


Example

  // Create a locator for a button
  const loginBtn = page.locator('#login');

  // No element is located yet âŒ

  // Element is located here when action is performed âœ…
  await loginBtn.click();



â³ Auto-Waiting & Retry-ability [WHAT IS THIS?]

    Playwright locators come with built-in waiting:

    - Auto-waiting: Before performing actions, Playwright waits for the element to exist, 
                    be visible, and be ready (e.g., clickable).

    - Retry-ability: If the element isnâ€™t immediately ready (e.g., DOM changes), Playwright 
                      retries until the timeout is reached.

    Example: await page.locator('#submit').click();
    // Playwright will automatically wait for #submit to appear, be visible, and be enabled 
    // before clicking.

    No need for manual waits like waitForSelector() in most cases.



ğŸ“Œ Key Interview Points:

    - Locators are declarative handles, not immediate element fetchers.
    - page.locator() does not find the element until you use an action or assertion.
    - Locators make scripts more stable and less flaky because of auto-wait & retry-ability.
    - Prefer locators over raw selectors for maintainability in modern automation





ğŸ§  What is a Selector?

  A selector is simply a string pattern that tells Playwright how to find an element in the DOM.

  Itâ€™s like an address for an element â€”
  you describe where it is, and Playwright/JavaScript will try to fetch it.

  Types of Selectors in Playwright

  Playwright supports multiple selector engines, not just CSS.



1ï¸âƒ£ CSS Selectors

  Classic way to match elements based on tag, class, ID, attributes.

  await page.click('#login');          // by ID
  await page.click('.btn-primary');    // by class
  await page.click('button[type="submit"]'); // by attribute



2ï¸âƒ£ Text Selectors

  Find elements by visible text.

  await page.click('text=Login');


3ï¸âƒ£ XPath Selectors

  Locate elements by XML-like path.

  await page.click('//button[@id="login"]');


4ï¸âƒ£ ARIA Selectors (Accessibility Tree)

  Find by role, name, or other ARIA properties.

  await page.getByRole('button', { name: 'Submit' }).click();


5ï¸âƒ£ Custom Selector Engines

  Playwright also supports:

      :has() â€” Find an element containing another element.
      :nth-match() â€” Match nth occurrence.
      :visible, :text, :has-text() â€” Filtering.


Selector Example:

    // Select by CSS
    await page.click('input[name="username"]');

    // Select by text
    await page.click('text=Forgot password?');

    // Select by ARIA role & name
    await page.getByRole('button', { name: 'Sign in' }).click();


Selectors vs Locators

    Selector = the string expression describing how to find an element.

    Locator = an API wrapper around a selector that adds:

        - Auto-wait
        - Retry-ability
        - Chaining
        - Filters

Example:

  // Selector only
  await page.click('#login');

  // Locator using selector
  const loginBtn = page.locator('#login');
  await loginBtn.click(); // with auto-wait + retry





ğŸ”µ What is getByRole()?

    getByRole() works on the Accessibility Tree (not raw DOM).

    It identifies elements by their ARIA role (explicit or implicit) + 
    accessible name (from aria-label, aria-labelledby, or inner text).



ğŸ“Œ Implicit vs Explicit Roles

    Implicit Role: Comes from the element type.

        Example: <button> â†’ role = button (even if role not written).

    Explicit Role: Developer sets it via role attribute.

        Example: <div role="navigation"> â†’ role = navigation.


ğŸ’¡ Key Tip

    If the element has role="navigation", then you must use: page.getByRole('navigation')
    Not getByRole('div'), because Playwright ignores HTML tags and only cares about the role + accessible name.


    In Playwright, getByRole() supports not only role + name, but also state filters like checked, 
    disabled, expanded, pressed, etc.
    These states come from ARIA or from the elementâ€™s native properties (disabled, checked, etc.).




ğŸ“ Using State in getByRole()

âœ… Example 1: Disabled button

  <button disabled>Checkout Button</button>
  <button>Checkout Button</button>

  Playwright:

  // Get only the disabled one
  const disabledBtn = page.getByRole('button', { name: 'Checkout Button', disabled: true });

  // Get only the enabled one
  const enabledBtn = page.getByRole('button', { name: 'Checkout Button', disabled: false });


âœ… Example 2: Checkbox with checked state

    <label>
      <input type="checkbox" checked> Subscribe
    </label>
    <label>
      <input type="checkbox"> Subscribe
    </label>

    Playwright:

    // Checked version
    const checkedBox = page.getByRole('checkbox', { name: 'Subscribe', checked: true });

    // Unchecked version
    const uncheckedBox = page.getByRole('checkbox', { name: 'Subscribe', checked: false });


âœ… Example 3: Expandable menu (aria-expanded)

    <button aria-expanded="true">Menu</button>
    <button aria-expanded="false">Menu</button>

    Playwright:

    // Expanded
    const expandedMenu = page.getByRole('button', { name: 'Menu', expanded: true });

    // Collapsed
    const collapsedMenu = page.getByRole('button', { name: 'Menu', expanded: false });


  âš¡ Pro Tip:
  ğŸ‘‰ These states (checked, disabled, expanded, pressed, selected) map directly to ARIA states or native 
      element properties.
  ğŸ‘‰ That makes your locator super precise and future-proof, even if the HTML structure changes.

Practice - check code of 3-locators-spec.js 

ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”




ğŸ–¼ï¸ Iframes in Playwright

ğŸ”µ What is an iframe?

    - An iframe (inline frame) is like a webpage inside another webpage.
    - It loads separate HTML (even from different domains) inside your main page.
    - Example: Payment gateways, ads, or embedded YouTube videos are often iframes.

<iframe src="payment.html"></iframe>

âš ï¸ Challenge in automation

- Elements inside an iframe are not part of the main DOM.
- If you try page.locator('#payBtn') directly, Playwright wonâ€™t find it.
- You need to switch context into the iframe first.

âœ… Playwright solution

Playwright gives frameLocator() to directly target elements inside iframes.

// Example: click button inside iframe
await page.frameLocator('iframe[src="payment.html"]').locator('#payBtn').click();

ğŸ‘‰ This avoids manually switching frames.
ğŸ‘‰ Works with nested iframes also.


ğŸ”— Locator Chaining in Playwright

ğŸ”µ What is it?

Locator chaining = finding an element relative to another element.
Instead of writing long selectors, you scope down step by step.

âœ… Example: Without chaining 

await page.locator('div.card button:has-text("Buy")').click();

âœ… Example: With chaining

const card = page.locator('div.card');        // Parent
await card.locator('button:has-text("Buy")').click();  // Child

- Here, we first locate the parent, then chain the child locator.
- This improves readability and reduces brittle selectors.


ğŸ”„ Iframes + Chaining Together [Best example of chaining locators]

If the button is inside a card which itself is inside an iframe:

await page
  .frameLocator('iframe#checkoutFrame')     // Switch to iframe
  .locator('div.card')                      // Parent
  .locator('button:has-text("Checkout")')   // Child
  .click();


Example:

test.only('iframe', async ({ page, browserName }) => {

  await page.goto('https://letcode.in/frame#google_vignette');

  // below is best example of locator chaining -
  // first we locate the iframe using its id, then we use frameLocator to get the frame inside the page
  // then we can use the frame locator to find elements inside the iframe
  // note that we are using the id of the iframe, not the src or name
  const iframeLoc = page.frameLocator('#firstFr');
  const inputBxLoc = iframeLoc.getByPlaceholder('Enter name');
  await inputBxLoc.fill('John Doe');

});

Practice - 3-locators.spec.ts


ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”




ğŸ”µ What is getByLabel()?

It locates a form control element (like input, textarea, select, checkbox, radio, etc.) 
by its associated labelâ€™s text.

Association between <label> and form control can be:

    1) Explicit association (using for + id)
    2) Implicit association (wrapping input inside <label> tag)

ğŸ–¥ï¸ How to Use getByLabel() in Playwright [check 02-label-practice.html for html source code]

// Explicit association
await page.getByLabel('Username').fill('john_doe');

// Explicit association
await page.getByLabel('Password').fill('secret123');

// Implicit association (checkbox wrapped in label)
await page.getByLabel('Remember Me').check();

// Dropdown by label
await page.getByLabel('Country').selectOption('USA');

âš ï¸ Where getByLabel() Works

âœ”ï¸ Works when:
    - There is a <label> with for attribute linking to input.
    - The input is wrapped inside <label>.
    - Label text is visible & readable.

ğŸš« Where it Doesnâ€™t Work

If the field has no <label> (only placeholder).

<input type="text" placeholder="Enter email">

ğŸ‘‰ Use getByPlaceholder() instead.
If the label is present but not linked properly (no for and input not inside label).
If the label text is hidden with CSS (display: none), Playwright may fail unless force option 
is used.

ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”




ğŸ”µ What is getByPlaceholder()?

It locates form input fields (<input>, <textarea>) by their placeholder text.
Placeholders are those light gray hints you see inside input boxes before typing.

Example: <input type="text" placeholder="Enter your email">

ğŸ‘‰ You can locate it in Playwright with:

await page.getByPlaceholder('Enter your email').fill('john@example.com');


âš ï¸ When to Use getByPlaceholder()

âœ”ï¸ Best when:
    - Inputs donâ€™t have labels but do have placeholder text.
    - Quick way for short forms (like login/signup).

ğŸš« Not recommended when:
    - Placeholders are missing or generic like "Type here...".
    - Placeholders change dynamically (localization, JS).
    - Accessibility â†’ placeholders are not read by screen readers (so getByLabel() is preferred).

ğŸ“ Interview-Ready Note
getByLabel() > getByPlaceholder() because labels are semantic & accessibility-friendly.


ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”



ğŸ”µ What is getByText()?

    It finds elements based on visible text content inside them.

    Works for any element (<button>, <div>, <span>, <p> etc.).

    Example:

    <button>Login</button>

    Locator: await page.getByText('Login').click();


âœ… exact: true

    âœ”ï¸ exact: true â†’ strict string match only, no regex.

    await page.getByText("Submit", { exact: true }).click();

    ğŸ‘‰ Matches only "Submit" (not "Submit Form", not "Submit Order")

    âš ï¸ What Will NOT Work

    âŒ If text is hidden with CSS (display:none, visibility:hidden) â†’ Playwright ignores it.
    âŒ If text comes from placeholder/label attributes â†’ use getByPlaceholder() or getByLabel() instead.
    âŒ If text is dynamically changing too fast without waiting â†’ need await page.waitForSelector() or auto-wait.

    ğŸ“ Interview Notes

    - getByText() â†’ visible text only (ignores hidden).
    - Supports string match, substring, regex.
    - For accessibility & maintainability, prefer getByRole({ name: '...' }) when possible.
    - Example: getByRole('button', { name: 'Login' }) is more stable than getByText('Login').

    Perfect ğŸ‘Œ Iâ€™ll give you a single HTML page that covers:
    âœ”ï¸ Strict text match
    âœ”ï¸ Substring match
    âœ”ï¸ Regex match (case-insensitive, startsWith, endsWith)
    âœ”ï¸ Hidden text (wonâ€™t be matched by Playwright)
    âœ”ï¸ Nested text


ğŸ”µ Key Notes

    - Strict text match â†’ must match exactly, including spaces/punctuation.
    - Substring â†’ works if text matches exactly within an element.
    - Regex â†’ flexible (case-insensitive, startsWith, endsWith).
    - Hidden text â†’ ignored automatically.
    - Nested text â†’ Playwright merges visible text from children.





ğŸ” Regex in getByText()

  page.getByText() normally matches exact text inside an element.

  But sometimes text on the page is:
      - Case-sensitive (Login vs login)
      - Contains extra spaces
      - Partially dynamic (Submit Form, Submit Order, Submit Request)

  ğŸ‘‰ In such cases, Regex is useful.




âœ… 1. Case-Insensitive Matching

    await page.getByText(/login/i).click();

    - /login/i â†’ i means ignore case.
    - Matches: Login, LOGIN, LoGiN, etc.

    ğŸ§  Interview Tip:

    If the interviewer asks, â€œHow do you handle case differences in text locators?â€, answer:
    â€œI use regex with /text/i inside getByText() to make it case-insensitive.â€


âœ… 2. Starts With

    await page.getByText(/^Submit/).click();

    - ^ â†’ matches text that starts with â€œSubmitâ€.
    - Matches: Submit Form, Submit Request, Submit, but NOT Form Submit.



âœ… 3. Ends With

    await page.getByText(/Now$/).click();

    - $ â†’ matches text that ends with â€œNowâ€.
    - Matches: Pay Now, Checkout Now, but NOT Now Pay.



âœ… 4. Contains / Partial Match

ğŸ” getByText â€” Exact vs Contains Match

1. Exact Match (default behaviour)

    By default, Playwright getByText("Error") poore element ke text ko exact match karta hai.

      await page.getByText("Error").click();

    ğŸ‘‰ Ye sirf tab chalega jab element ka text exactly "Error" ho.

      âœ” Matches: <div>Error</div>
      âŒ Does not match: <div>Error occurred</div>


2. Partial Match (Regex or Substring)

(a) Regex Match

  Agar tu substring / contains dhoondhna chahta hai, toh regex use kar:

  await page.getByText(/error/).click();

  ğŸ‘‰ Ye case-insensitive banane ke liye /error/i use kar:

      await page.getByText(/error/i).click();

  âœ” Matches: Error Occurred, Critical Error, error in input

  âŒ Does not match: Success, Warning


(b) Substring Match (exact: false)

    Playwright me getByText ke options me exact: false pass kar sakta hai. 
    Ye internally substring match karta hai.

      await page.getByText("error", { exact: false }).click();


    ğŸ‘‰ Ye bhi "error" ko anywhere in text match karega.

      âœ” Matches: "Error Occurred", "Some error in input"
      âŒ Does not match: "Success"




âœ… 5. Multiple Options

    await page.getByText(/(Submit|Save|Confirm)/).click();

    - Matches if element has text Submit OR Save OR Confirm.

    ğŸ§  This is great for dynamic UIs where button text changes.




âœ… 6. Whitespace Tolerant

    await page.getByText(/Sign\s+Up/).click();

    \s+ â†’ matches any number of spaces/tabs.

    Matches: Sign Up, Sign Up, Sign Up.



âœ… 7. Dynamic Numbers / Values

    await page.getByText(/Items in cart: \d+/).click();

    \d+ â†’ matches one or more digits.

    Matches: Items in cart: 3, Items in cart: 15.




âš¡ Why Regex is Useful in Playwright

    UI text often changes slightly (Pay Now â†’ Checkout Now).
    Regex makes locators resilient (not breaking for small wording changes).
    Handles case insensitivity without writing multiple locators.
    Helps with dynamic content (numbers, changing labels, etc.).

â“ Q: When would you use regex in Playwright locators like getByText()?

    âœ”ï¸ A: I use regex when I want flexibility in matching text. For example: case-insensitive 
    matches (/login/i), partial matches (/Submit/), starts/ends with (/^Submit/, /Now$/), or 
    handling dynamic values (/Items in cart: \d+/). This keeps my locators stable and prevents 
    flakiness when UI text changes slightly.


1. [A-Z] â†’ koi bhi ek uppercase character

<div>A</div>
<div>Z</div>
<div>Submit</div>


Code:

await page.getByText(/[A-Z]/).first().click();


ğŸ‘‰ Explanation:

  - [A-Z] ka matlab hai: ek bhi uppercase letter (A se Z tak).
  - Matches: "A", "Z".
  - âš ï¸ "Submit" bhi match karega, kyunki S capital hai.
  - Matlab regex ne check kiya: "Submit" ke andar uppercase letter hai? â†’ haan â†’ match.



2. [a-z] â†’ koi bhi ek lowercase character


<div>a</div>
<div>z</div>
<div>Login</div>


Code: await page.getByText(/[a-z]/).first().click();

ğŸ‘‰ Explanation:

- [a-z] ka matlab hai: ek bhi lowercase letter (a se z tak).
- Matches: "a", "z".
- "Login" bhi match karega, kyunki "o", "g", "i", "n" sab lowercase letters hain.
- Matlab regex ke liye poore string ka lowercase hona zaroori nahi hai, bas kahin bhi ek lowercase letter ho 
  toh match ho jaata hai.



3. [A-Za-z]{4} â†’ exactly 4 letters in sequence


<div>Test</div>
<div>Play</div>
<div>Login</div>
<div>Go</div>


Code: await page.getByText(/[A-Za-z]{4}/).click();


ğŸ‘‰ Explanation:

- [A-Za-z]{4} ka matlab: lagataar 4 letters hone chahiye (uppercase/lowercase mix allowed).
- Matches:
    "Test" â†’ 4 letters âœ…
    "Play" â†’ 4 letters âœ…
    âŒ "Login" â†’ 5 letters hai, so 4 ka pattern isme fit nahi hota.
    âŒ "Go" â†’ sirf 2 letters hai.

âš¡ Lekin dhyaan: agar text me 4 letters ka substring hai toh wo bhi match karega. Example: "Login" ke pehle 4 
letters "Logi" 4 letters hai â†’ toh isko bhi match kar lega. Agar tu chaahta hai ki poore word hi 4 letters ke ho,
 toh anchor use karna hoga (neeche samjhata hoon).


 4. Anchors ^ aur $ â†’ strict match

^ â†’ string ki shuruaat
$ â†’ string ka end

await page.getByText(/^[A-Za-z]{4}$/).click();


ğŸ‘‰ Explanation:

/^[A-Za-z]{4}$/ ka matlab:

  ^ = start se hi letters
  [A-Za-z]{4} = total 4 letters
  $ = uske baad kuch nahi hona chahiye

Matches sirf wahi text jisme poora content exactly 4 letters ho.
  "Test", "Play" âœ…
  "Login" âŒ (5 letters)
  "Go" âŒ (2 letters)
  "Play123" âŒ (extra characters hain)



ğŸ‘‰ difference between

/[A-Za-z]{4}/

/^[A-Za-z]{4}$/


1. /[A-Za-z]{4}/ â†’ substring match

Isme anchors (^ aur $) nahi hain.
Matlab regex poore string ke andar kahin bhi 4 lagataar letters dhoondhega.
Agar mil gaya â†’ match âœ….

Example:

<div>Test</div>
<div>Play</div>
<div>Login</div>
<div>Go</div>

await page.getByText(/[A-Za-z]{4}/).click();


ğŸ‘‰ Matches:

  "Test" âœ… (poore hi 4 letters)
  "Play" âœ… (poore hi 4 letters)
  "Login" âœ… (kyunki "Logi" first 4 letters match kar rahe hain)
  "Go" âŒ (sirf 2 letters)

âš ï¸ Dhyaan: "Login" bhi match ho gaya, kyunki uske pehle 4 letters "Logi" pattern ko satisfy karte hain.


2. /^[A-Za-z]{4}$/ â†’ whole string match

^ = start of string
[A-Za-z]{4} = exactly 4 letters
$ = end of string
Matlab poora text hi sirf 4 letters ka hona chahiye, na kam na zyada.

await page.getByText(/^[A-Za-z]{4}$/).click();


ğŸ‘‰ Matches:

  "Test" âœ… (4 letters, poora match)
  "Play" âœ… (4 letters, poora match)
  "Login" âŒ (5 letters)
  "Go" âŒ (2 letters)

ğŸ¯ Simple Difference in One Line

  /[A-Za-z]{4}/ â†’ check karta hai ki kahin bhi 4 continuous letters ho. (Substring match)
  /^[A-Za-z]{4}$/ â†’ check karta hai ki poora text hi exactly 4 letters ka ho. (Exact match)


1. [0-9]{4} â†’ substring me kahin bhi 4 continuous digits



<div>1234</div>
<div>912345</div>
<div>99</div>


await page.getByText(/[0-9]{4}/).click();

ğŸ‘‰ Matches:

  "1234" âœ… (exact 4 digits)
  "912345" âœ… (kyunki "9123" ya "1234" substring match ho jata hai)
  "99" âŒ (sirf 2 digits hai)



2. /^[0-9]{4}$/ â†’ poora text hi exactly 4 digits hona chahiye

  await page.getByText(/^[0-9]{4}$/).click();


ğŸ‘‰ Matches:

    "1234" âœ… (poora text 4 digits ka hai)
    "912345" âŒ (6 digits)
    "99" âŒ (2 digits)




3. Mixed case (letters + numbers)

<div>Order1234</div>
<div>AB12</div>
<div>5678</div>


// substring 4 digits kahin bhi
await page.getByText(/[0-9]{4}/).click(); 
// âœ… Matches "Order1234" (last 4 digits), "5678"

// exactly 4 digits aur kuch nahi
await page.getByText(/^[0-9]{4}$/).click(); 
// âœ… Matches only "5678"




ğŸ“Œ Summary

exact: true â†’ strict string match.
Regex [A-Z] â†’ matches any uppercase letter inside text.
Regex [a-z] â†’ matches any lowercase letter inside text.
Regex [A-Za-z]{4} â†’ matches exactly 4-letter words.
^...$ â†’ anchors to match the whole string exactly.


ğŸ¯ Summary

[0-9] â†’ ek digit (0 se 9)
[0-9]{4} â†’ lagataar 4 digits kahin bhi text ke andar
/^[0-9]{4}$/ â†’ poora text sirf aur sirf 4 digits ka ho


âš¡ Example use case in testing:
PIN code validation â†’ /^[0-9]{4}$/ (sirf 4 digits allowed, aur kuch nahi)
Order number search â†’ /[0-9]{4}/ (text me kahin bhi 4 digits aa jaye toh chalega)