ðŸ”´ Problem Statement

When we register a dialog listener with:

page.on('dialog', async dialog => {
  console.log(dialog.message());
  await dialog.accept();
});

and trigger multiple dialogs in one test (like alert â†’ confirm â†’ prompt), Playwright throws an error:

Error: Target closed or Dialog already handled


ðŸ‘‰ Reason:

.on registers a permanent listener.

That listener will try to handle every dialog, even dialogs that are already resolved.

As a result, Playwright complains that the dialog was "already handled".

e.g.

test('Dialogs Practice', async ({ page, browserName }) => {

    await page.goto('http://127.0.0.1:5500/tests/09-dialogs.html');

    // Alert
    console.log('Alert Dialogs Practice');
    page.on('dialog', async dialog => {
        console.log(dialog.message()); // "This is an Alert dialog!"
        await dialog.accept();
    });
    await page.getByText('Show Alert').click();
    console.log();


    // Confirm
    console.log('Confirm Dialogs Practice');
    page.on('dialog', async dialog => {
        console.log(dialog.message()); // "Do you want to continue?"
        await dialog.dismiss();        // Click Cancel
    });
    await page.getByText('Show Confirm').click();
    console.log();

});

if u run above script it will throw error that - dialog is already handled 



ðŸŸ¢ Resolution

Instead of .on, we use .once:

ðŸ‘‰ .once ensures the listener is automatically removed after handling one dialog only.
So each dialog has its own handler, preventing conflicts.

so we rectified it with solution : i.e. replaced on with once


test('Dialogs Practice', async ({ page, browserName }) => {

    await page.goto('http://127.0.0.1:5500/tests/09-dialogs.html');

    // Alert
    console.log('Alert Dialogs Practice');
    page.once('dialog', async dialog => {
        console.log(dialog.message()); // "This is an Alert dialog!"
        await dialog.accept();
    });
    await page.getByText('Show Alert').click();
    console.log();


    // Confirm
    console.log('Confirm Dialogs Practice');
    page.once('dialog', async dialog => {
        console.log(dialog.message()); // "Do you want to continue?"
        await dialog.dismiss();        // Click Cancel
    });
    await page.getByText('Show Confirm').click();
    console.log();

});



âœ… .on('dialog')

Used when you want to handle all dialogs globally.

Example: If your application triggers alerts frequently and you always want to dismiss them.

page.on('dialog', dialog => dialog.dismiss());

âš ï¸ Risky inside a single test with multiple dialog types â†’ may cause "already handled" errors.


âœ… .once('dialog')

Used when you know exactly one dialog will appear after a specific action.

Cleaner for test automation.

Example:

await page.getByText('Submit').click();
page.once('dialog', dialog => dialog.accept());


ðŸ“Œ When to Use

| Use Case                                                               | Use `.on()`            | Use `.once()`                     |
| ---------------------------------------------------------------------- | ---------------------- | --------------------------------- |
| Want a **global handler** for all dialogs (like always dismiss alerts) | âœ… Yes                  | âŒ No                              |
| Expecting a **single dialog per action**                               | âŒ Not ideal            | âœ… Best choice                     |
| Handling **multiple dialogs in one test**                              | âŒ Will cause conflicts | âœ… Use separate `.once` per dialog |
| Debugging / logging all dialogs that appear                            | âœ… Good                 | âŒ Not useful                      |


ðŸ“ Interview-ready Answer

ðŸ‘‰ In Playwright, dialogs like alert, confirm, and prompt block the page until handled. 
If we use page.on('dialog'), the handler stays active for all dialogs, which can lead to 
â€œdialog already handledâ€ errors when multiple dialogs appear in one test.

To avoid this, we use page.once('dialog'), which handles only the next dialog and then unregisters itself.

    .on â†’ global handler, good for continuous listening across tests.
    .once â†’ one-time handler, best when you know one specific dialog will appear after an action.


    --------------------------------------------------------------


Q - Y we are handing prompt before click and not after click?  

    page.once('dialog', async dialog => {
        console.log(dialog.message()); // "Enter your name:"
        await dialog.accept("Playwright User");
    });
    await frame1.locator('#open-dialog').click();

ðŸ”¹ Browser dialogs (alert / prompt / confirm) kaise kaam karte hain?

    Jab tum page pe alert / confirm / prompt trigger karte ho (like window.prompt()),
    browser turant dialog block karke khada ho jaata hai.

    Jab tak tum us dialog ko accept/dismiss nahi karte, page ka JS execution ruk jata hai.


1ï¸âƒ£ page.once('dialog', handler) pehle likhna

    Is line ka matlab hai:
      â€œAgar agle step mein koi dialog open hua, to is handler ko chalana.â€
    Matlab tum listener register kar rahe ho before the dialog actually appears.


2ï¸âƒ£ click() likhna

    Jab tum click karte ho button pe (#open-dialog), tabhi window.prompt() fire hota hai.
    Us samay Playwright turant dekhta hai ki tumne listener lagaya hai, to usko handle kar deta hai.


âŒ Agar tum listener ko baad mein lagate

    await frame1.locator('#open-dialog').click();
    page.once('dialog', async dialog => { ... }); // âŒ too late

    Yahaan click ke turant baad browser dialog khol dega.

    Lekin tum listener baad mein register kar rahe ho â†’ dialog handle hi nahi hoga.

    Result: test stuck ho jayega ya timeout dega, kyunki Playwright wait karega ke tum dialog ko accept/dismiss karo.


ðŸ”‘ Conclusion

    ðŸ‘‰ Isliye pehle listener lagana zaruri hai, phir woh action trigger karo jo dialog open kare.

    Before: listener ready hai â†’ dialog safely handle ho jaata hai.

    After: dialog pehle aa gaya, listener baad mein â†’ test atak jaata hai.




Q1. What are listeners in Playwright?

ðŸ‘‰ In Playwright, listeners are callbacks attached to specific events (like dialog, console, request, etc.). 
    Whenever that event occurs during test execution, the callback automatically executes. 
    They are similar to JavaScript's addEventListener.


Listener ka simple matlab hai: ek callback jo kisi specific event ke trigger hone par chal jata hai.

Ye wahi concept hai jo tum JS mein addEventListener se sunte ho.

Playwright mein bhi har object (page, browser, context, etc.) ke apne events hote hain, aur tum inko listen kar sakte ho.


ðŸ”¹ Listener in your code

Tumne ye likha tha:

page.once('dialog', async dialog => {
  console.log(dialog.message()); // "Enter your name:"
  await dialog.accept("Playwright User");
});


Yahaan:

    page.once(...) hi ek listener hai.

    'dialog' â†’ ye event ka naam hai (jab alert/confirm/prompt dialog open hoga).

    async dialog => { ... } â†’ ye tumhara callback hai (jo event trigger hote hi chalega).

    âš¡ Matlab:

    Ye listener bol raha hai: â€œJab page pe ek dialog event aaye, to is function ko ek baar chalana

ðŸ”¹ once vs on

    page.on(event, handler) â†’ har baar jab event fire hoga, handler chalega (multiple times).

    page.once(event, handler) â†’ sirf ek hi baar chalega, fir auto remove ho jayega.



ðŸ”¹ Different listeners in Playwright

Playwright mein alag-alag objects ke alag-alag listeners hote hain.
Kuch common Page events:

| Event name       | Description                                                       |
| ---------------- | ----------------------------------------------------------------- |
| `dialog`         | Triggered when an alert/confirm/prompt appears.                   |
| `console`        | Triggered when `console.log` (ya koi bhi console event) hota hai. |
| `request`        | Jab bhi page se koi network request jaati hai.                    |
| `response`       | Jab network response aata hai.                                    |
| `requestfailed`  | Jab koi request fail hoti hai.                                    |
| `framenavigated` | Jab ek frame navigate hota hai.                                   |
| `load`           | Jab page ka load event fire hota hai (DOM loaded).                |
| `pageerror`      | Jab page pe uncaught error aata hai.                              |
| `worker`         | Jab ek new web worker start hota hai.                             |


BrowserContext listeners:

    page â†’ Jab naya page open hota hai.

    close â†’ Jab context close hota hai.

Browser listeners:

    disconnected â†’ Jab browser disconnect hota hai.



ðŸ”¹ Example: Listening to multiple events

page.on('console', msg => {
  console.log('PAGE LOG:', msg.text());
});

page.on('request', req => {
  console.log('âž¡ï¸ Request:', req.url());
});

page.on('response', res => {
  console.log('â¬…ï¸ Response:', res.url(), res.status());
});




Q2. Can you show me an example of a listener in Playwright?
ðŸ‘‰ Example of listening to a dialog event:

page.once('dialog', async dialog => {
  console.log(dialog.message()); 
  await dialog.accept("Playwright User");
});
await page.click('#open-dialog');


Here:

    'dialog' â†’ event name

    dialog => {...} â†’ listener (callback function)

    once means it will listen only once for this event.


Q3. Why do we register a dialog listener before clicking the button that triggers it?
ðŸ‘‰ Because dialogs (alert/prompt/confirm) block JavaScript execution when they appear.
If we click first and register listener later, the test will hang because the dialog is already blocking.
So we must register the listener before the action that triggers it.


Q4. What is the difference between page.on and page.once?
ðŸ‘‰

    page.on(event, handler) â†’ listens to an event every time it happens (multiple times).

    page.once(event, handler) â†’ listens only once, then automatically removes itself.

    Example:

    page.on('console', msg => console.log(msg.text())); // listens continuously
    page.once('dialog', d => d.accept());              // listens only once


Q5. What are some common listeners available in Playwright?
ðŸ‘‰ Some important event listeners:

Page events:

        dialog â†’ when alert/confirm/prompt appears

        console â†’ when console.log/error/warn happens

        request â†’ when a network request is made

        response â†’ when a network response is received

        requestfailed â†’ when a request fails

        framenavigated â†’ when a frame navigates

        pageerror â†’ when an uncaught exception occurs in the page

BrowserContext events:

        page â†’ when a new page is created

        close â†’ when context is closed

Browser events:

        disconnected â†’ when browser gets disconnected


Q6. Can you give an example of using multiple listeners in a test?


page.on('console', msg => console.log('LOG:', msg.text()));

page.on('request', req => console.log('âž¡ï¸ Request:', req.url()));

page.on('response', res => console.log('â¬…ï¸ Response:', res.url(), res.status()));

page.once('dialog', async dialog => {
  console.log('Dialog message:', dialog.message());
  await dialog.accept();
});


This will log console messages, track network requests/responses, and handle a dialog.



Q7. Why are listeners useful in automation tests?
ðŸ‘‰ Listeners help in:

        Handling unexpected dialogs

        Capturing console errors/warnings

        Debugging network requests/responses

        Monitoring navigation events

        Validating app behavior beyond just UI interactions


Q8. Can listeners be removed after adding them?
ðŸ‘‰ Yes, by using page.off(event, handler).

const handler = msg => console.log(msg.text());
page.on('console', handler);

// Later if you want to stop listening:
page.off('console', handler);
