âœ… TestNG DataProvider kya karta hai?

Ek hi test ko multiple sets of data ke sath run karne ka tareeka deta hai.

Example: same login test chalana with 10 different usernames/passwords.


âœ… Playwright (JavaScript/TypeScript) me equivalent?
[But both below are not ideal apporach then what is ideal approach - see framework part]

Haan, Playwright me bhi data-driven tests easily kiye jaa sakte hain, 
lekin thoda alag style hai (kyunki Playwright @playwright/test runner use karta hai, 
TestNG jaisa framework nahi).



ðŸ”¹ 1. Pehle forEach + test simple example (without describe)


      import { test, expect } from '@playwright/test';

      const testCases = [
          { username: "rahul", password: "pass123", expected: "Login successful!" },
          { username: "wrong", password: "wrong", expected: "Invalid username or password!" },
      ];

      //  ðŸ‘‰ Yaha correct credentials = rahul / pass123

      testCases.forEach(({ username, password, expected }) => {
          test(`Login test for user=${username}`, async ({ page }) => {
              await page.goto("http://127.0.0.1:5500/tests/25-dataprovider-practice.html");

              await page.fill("#username", username);
              await page.fill("#password", password);
              await page.click("button");

              const msg = page.locator("#message");
              await expect(msg).toHaveText(expected);
          });
      });


      ðŸ‘‰ Ye bilkul DataProvider jaisa hi hai: ek hi test multiple data sets ke liye chal raha hai.
      And when u go in testrunner part of vs code, you will see 2 tests for above.
      And also in report you will see 2 tests ran.




      ðŸ”¹ 2. Array vs Object (Simple Diff)

      Array ([])
      Ordered collection of values. Elements ko index se access karte ho (arr[0], arr[1]).

      Example:

      const arr = [10, 20, 30];
      console.log(arr[0]); // 10


      Object ({})
      Keyâ€“value pairs ka collection. Keys string ya symbol hote hain, aur values kuch bhi ho sakti hain.

      Example:

      const obj = { name: "Rahul", age: 25 };
      console.log(obj.name); // Rahul


      ðŸ‘‰ Tumhaare test cases ek Array of Objects hain.

      Array = outer []

      Object = andar ke { username: ..., password: ... }




      ðŸ”¹ 3. forEach + Destructuring Samajh

      Jab hum forEach karte hain:

      testCases.forEach(({ username, password, expected }) => {
        console.log(username, password, expected);
      });


      Yahaan pe har ek testCase actually ek object hai jisme teen keys hain: username, password, expected.

      Normal likho toh:

      testCases.forEach((testCase) => {
        console.log(testCase.username, testCase.password, testCase.expected);
      });


      Destructuring shortcut hai:

      testCases.forEach(({ username, password, expected }) => {
        console.log(username, password, expected);
      });




      ðŸ”¹ 4. Agar Different Keys Hain

      Maan lo tumhaare array me alag-alag objects hain jinke keys different hain:

      const testCases = [
        { username: "rahul", password: "pass123", expected: "Login successful!" },
        { email: "wrong@example.com", password: "wrong", error: "Invalid email!" },
      ];


      Ab tum forEach me directly { username, password, expected } nahi kar sakte kyunki doosre object me username hi nahi hai.

      âœ… Iske liye tumhe generic param lena hoga:

      testCases.forEach((data) => {
        if ("username" in data) {
          console.log("Username login:", data.username, data.password, data.expected);
        } else if ("email" in data) {
          console.log("Email login:", data.email, data.password, data.error);
        }
      });


      Ya phir different describe blocks banao:

      import { test, expect } from "@playwright/test";

      const usernameCases = [
        { username: "rahul", password: "pass123", expected: "Login successful!" },
      ];

      const emailCases = [
        { email: "wrong@example.com", password: "wrong", error: "Invalid email!" },
      ];

      test.describe("Username login tests", () => {
        usernameCases.forEach(({ username, password, expected }) => {
          test(`Login test with username=${username}`, async ({ page }) => {
            // test code
          });
        });
      });

      test.describe("Email login tests", () => {
        emailCases.forEach(({ email, password, error }) => {
          test(`Login test with email=${email}`, async ({ page }) => {
            // test code
          });
        });
      });


      5. Summary

      Array = [] (ordered list, index se access hota hai).

      Object = {} (keyâ€“value pairs, keys se access hota hai).

      Tumhaare testCases = Array of Objects.

      forEach(({ username, password, expected }) => {}) ek destructuring shortcut hai.

      Agar objects ke keys alag-alag hain, toh destructuring directly use nahi karna, 
      instead conditional ya alag arrays/describes use karo.


ðŸ”¹ 2. Pehle forEach + test.describe example 

import { test, expect } from "@playwright/test";

const testCases = [
  { username: "rahul", password: "pass123", expected: "Welcome rahul" },
  { username: "wrong", password: "wrong", expected: "Invalid credentials" }
];

test.describe("Login Tests (Data Driven)", () => {
  testCases.forEach(({ username, password, expected }) => {
    test(`Login test for ${username}`, async ({ page }) => {
      // test steps
    });
  });
});

ðŸ‘‰ Ab kya hoga? Report me output aise dikhai dega:

Login Tests (Data Driven)
  âœ“ Login test for rahul
  âœ“ Login test for wrong

  Yaani describe ek group banata hai (suite), jiske andar sare tests organized hote hain.


ðŸ¤” Simple samajh:

Without describe â†’ tests directly "flat" list me aayenge.

With describe â†’ tests ek suite ke andar group ho jaayenge, jisse readability/reporting 
better hoti hai.

agar tumhare describe ke andar do alag-alag test suites ya scenarios hain (e.g. Login aur Signup), 
aur dono data-driven hain, toh dono me alag forEach() lagana padega.

import { test, expect } from "@playwright/test";

// Login ke liye test data
const loginCases = [
  { username: "rahul", password: "pass123", expected: "Welcome rahul" },
  { username: "wrong", password: "wrong", expected: "Invalid credentials" }
];

// Signup ke liye test data
const signupCases = [
  { username: "newuser", password: "newpass", expected: "Signup successful" },
  { username: "rahul", password: "pass123", expected: "User already exists" }
];

test.describe("User Tests", () => {
  // Login tests
  test.describe("Login Suite", () => {
    loginCases.forEach(({ username, password, expected }) => {
      test(`Login test for ${username}`, async ({ page }) => {
        await page.goto("http://localhost:3000/login");
        await page.fill("#username", username);
        await page.fill("#password", password);
        await page.click("#loginBtn");

        const message = await page.textContent("#message");
        expect(message).toBe(expected);
      });
    });
  });

  // Signup tests
  test.describe("Signup Suite", () => {
    signupCases.forEach(({ username, password, expected }) => {
      test(`Signup test for ${username}`, async ({ page }) => {
        await page.goto("http://localhost:3000/signup");
        await page.fill("#username", username);
        await page.fill("#password", password);
        await page.click("#signupBtn");

        const message = await page.textContent("#message");
        expect(message).toBe(expected);
      });
    });
  });
});


ðŸ“ Output report me kuch aisa dikhega:

User Tests
  Login Suite
    âœ“ Login test for rahul
    âœ“ Login test for wrong
  Signup Suite
    âœ“ Signup test for newuser
    âœ“ Signup test for rahul


ðŸ‘‰ Conclusion:

    - Agar multiple types ke tests hain (Login, Signup, etc.), toh har ek ke liye apna forEach() 
      lagega.
    
    - describe ka kaam bas grouping aur reporting ko clean banana hai

  
ðŸ“ Note on Improving Data Driven Testing in Playwright
    - Test data ko ek loginData.json file me rakho:
    - Fir Playwright test file me fs ya require/import se data read karo


    â“ Question:

    "Playwright me data-driven testing kaise karte ho? Kya TestNG jaisa DataProvider concept hai?"
    
    âœ… Sample Answer (what you should say in interview):
    
    ðŸ‘‰ â€œPlaywright me direct TestNG jaisa @DataProvider concept nahi hai, lekin hum data-driven testing easily kar sakte hain JavaScript/TypeScript ke native features ka use karke.â€
    
    ðŸ”¹ Approach 1: Array of Objects (inline data)
    
    Hum test data ko ek array of objects ke form me bana lete hain.
    
    Fir forEach() loop ka use karke har ek data set ke liye ek test case generate karte hain.
    
    Example:
    
    const loginCases = [
      { username: "rahul", password: "pass123", expected: "Welcome rahul" },
      { username: "wrong", password: "wrong", expected: "Invalid credentials" }
    ];
    
    loginCases.forEach(({ username, password, expected }) => {
      test(`Login test for ${username}`, async ({ page }) => {
        // steps + assertion
      });
    });
    
    
    ðŸ‘‰ Is tarah har iteration ek independent test ban jaata hai.
    
    ðŸ”¹ Approach 2: Grouping with test.describe() + forEach
    
    Agar hum ek suite ke andar sare data-driven tests ko organize karna chahte hain, to test.describe() ka use karte hain.
    
    Ye reporting aur readability ko improve karta hai.
    
    Example:
    
    test.describe("Login Tests", () => {
      loginCases.forEach(({ username, password, expected }) => {
        test(`Login test for ${username}`, async ({ page }) => {
          // steps + assertion
        });
      });
    });
    
    
    ðŸ”¹ Improvement: Large Data via JSON File
    
    Agar test data bada ho ya frequently change hota ho, to best practice ye hoti hai ki hum data ko ek separate JSON file me rakh lein.
    
    Fir test file me JSON ko import karke forEach loop me use kar lete hain.
    
    Ye ek tarike se Playwright me DataProvider ka equivalent ban jaata hai.
    

    b